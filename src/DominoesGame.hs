module DominoesGame where
import Dominoes
import MergeSort
import System.Random 
import Data.Maybe
import Data.List
import Data.Ord (comparing)
type DomsPlayer = Hand -> Board -> (Domino, End)
-- | The deleteDom function searches a Hand for a given Domino and removes it.
deleteDom :: Domino -> Hand -> Hand
deleteDom d [] = []
deleteDom d (h:hs) 
  | h == d || h == swap d = hs 
  | otherwise = h : deleteDom d hs
-- | The genAllDoms function generates a list of all valid Dominoes in the
--   standard position - that is, with the greater number first.
genAllDoms :: [Domino]
genAllDoms = [(x,y) | x <- [0..6], y <- [0..6], defaultPositionP (x,y)]
-- | The shuffleDoms function shuffles the list generated by the above function
--   according to a provided integer, which is the seed for the random number
--   generator.
shuffleDoms :: Int -> [Domino]
shuffleDoms seed =  
        let randomList = take 28 (randoms (mkStdGen seed) :: [Int])
            dominoList = genAllDoms
            zippedList = zip dominoList randomList
            sortedList = mergesort (\(_,n1) (_,n2)->n1<n2) zippedList
         in (map fst sortedList)
-- | The dealDoms function forms two random starting hands from the above 
--   function. This is provided in a pair of hands.
dealDoms :: Int -> (Hand, Hand)
dealDoms seed =  splitAt 9 (take 18 (shuffleDoms seed))
-- | The simplePlayer function loops through a Hand, assuming that a Domino is
--   playable, and takes the first one that can be played alongside the end it
--   is playable at.
simplePlayer :: DomsPlayer
simplePlayer (d:h) b
 | goesSwappedP d L b = (d, L)
 | goesSwappedP d R b = (d, R)
 | otherwise = simplePlayer h b
-- | fst3 is a helper function that returns the first element of a 3-tuple. It
--   is necessary to extract the score from the mapping functions in hsdPlayer.
fst3 :: (a, b, c) -> a
fst3 (x, _, _) = x
-- | The convertHighestScoreResult function does just that - the mapping
--   function in hsdPlayer outputs in the form (score, end, domino), so this
--   function returns the standard output form of any DomsPlayer function with 
--   that given input.
convertHighestScoreResult :: (Int, End, (Int, Int)) -> (Domino, End)
convertHighestScoreResult (s, e, d) = (d, e)
-- | The hsdPlayer function finds the highest-scoring domino in the provided
--   hand, and returns it with the end at which it is playable.
hsdPlayer :: DomsPlayer
hsdPlayer h b = let (ppl, ppr) = possPlays h b ([],[])
                    -- Relatively self-explanatory, but the mapping function
                    -- adds contextual data to the dominoes in each list - score
                    -- and side at which it is playable for that score.
                    left = map (\(x,y) -> (scoreDom (x,y) L b, L, (x,y))) ppl
                    right = map (\(x,y) -> (scoreDom (x,y) R b, R, (x,y))) ppr
                    dom = head (reverse (sortBy (comparing fst3) (left ++ right)))
                 in (convertHighestScoreResult dom)
-- | The singleMove function emulates the result of a single move made by a
--   DomsPlayer, returning the score given by their move, the resulting board,
--   and their hand after making the move.
singleMove :: DomsPlayer -> Hand -> Board -> (Int, Board, Hand)
singleMove p h b
  | knockingP h b = (0,b,h)
  | otherwise = let (d,e) = p h b
                    board = fromJust (playDom d e b)
                    score = scoreBoard board
                    hand  = deleteDom d h
                 in ((score, board, hand))
-- | The playRound function extends singleMove to emulate the process of each
--   DomsPlayer taking their turn, returning the final scores and state of the
--   board when neither player can make a further move.
playRound :: (DomsPlayer, Int, Hand) -> (DomsPlayer, Int, Hand) 
          -> Board -> ((Int, Int),Board)
playRound (p1,p1s,p1h) (p2,p2s,p2h) b = 
    let (p1ns, t1b, p1nh) =  singleMove p1 p1h b
        (p2ns, t2b, p2nh) =  singleMove p2 p2h t1b
     in if knockingP p1nh t2b && knockingP p2nh t2b 
           then ((p1ns+p1s, p2ns+p2s), t2b) 
           else playRound (p1,p1ns+p1s,p1nh) (p2,p2ns+p2s,p2nh) t2b
-- | The playDomsRound function uses the above with the dealDoms function to
--   initialise both DomsPlayers and display the result of a game between them.
playDomsRound :: DomsPlayer -> DomsPlayer -> Int -> ((Int, Int),Board)
playDomsRound p1 p2 seed = let (p1h,p2h) = dealDoms seed
                               b = []
                               (scores, board) = playRound (p1,0,p1h) (p2,0,p2h) b
                            in (scores,board)
